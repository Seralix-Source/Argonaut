from collections.abc import Iterable, Sequence, Mapping
from enum import IntEnum
from typing import Protocol, Never, Any
from typing import type_check_only  # NOQA: Needed

from rich.text import Text

from argonaut.utils import UnsetType


class FaultCode(IntEnum):
    UNKNOWN_COMMAND: FaultCode
    UNKNOWN_SUBCOMMAND: FaultCode
    MALFORMED_TOKEN: FaultCode
    UNKNOWN_SWITCH: FaultCode
    FLAG_ASSIGNMENT: FaultCode
    MISSING_INLINE_VALUE: FaultCode
    DUPLICATED_SWITCH: FaultCode
    STANDALONE_SWITCH: FaultCode
    OPTION_VALUE_REQUIRED: FaultCode
    INLINE_EXTRA_VALUES: FaultCode
    AT_LEAST_ONE_VALUE_REQUIRED: FaultCode
    NOT_ENOUGH_VALUES: FaultCode
    EMPTY_VALUE: FaultCode
    INVALID_CHOICE: FaultCode
    MISSING_CARDINALS: FaultCode
    UNPARSED_TOKENS: FaultCode
    UNEXPECTED_CARDINAL: FaultCode
    DELEGATED_ERROR: FaultCode
    EMPTY_INLINE_VALUE: FaultCode
    DEPRECATED_ARGUMENT: FaultCode
    DELEGATED_WARNING: FaultCode

    def normalize(self) -> str: ...


@type_check_only
class Triggerable(Protocol):
    def __trigger__(self) -> None: ...
    def __replace__(self, *unused: Never, **overrides: Any) -> Triggerable: ...


class CommandException(Exception):
    message: str | UnsetType
    options: Mapping[str, Any]
    def __init__(self, message: str = ..., /, **options: Any) -> None: ...
    def __rich__(self) -> Text: ...
    def __trigger__(self) -> None: ...
    def __replace__(self, *unused: Never, **overrides: Any) -> CommandException: ...

class MalformedTokenError(CommandException): ...
class UnknownSwitchError(CommandException): ...
class FlagAssignmentError(CommandException): ...
class UnknownCommandError(CommandException): ...
class UnknownSubcommandError(CommandException): ...
class UnexpectedCardinalError(CommandException): ...
class DuplicatedSwitchError(CommandException): ...
class MissingInlineValueError(CommandException): ...
class OptionValueRequiredError(CommandException): ...
class InlineExtraValuesError(CommandException): ...
class AtLeastOneValueRequiredError(CommandException): ...
class NotEnoughValuesError(CommandException): ...
class DelegatedCommandError(CommandException): ...
class EmptyValueError(CommandException): ...
class InvalidChoiceError(CommandException): ...
class StandaloneSwitchError(CommandException): ...
class MissingCardinalsError(CommandException): ...
class UnparsedTokensError(CommandException): ...

class CommandWarning(Warning):
    message: str | UnsetType
    options: Mapping[str, Any]
    def __init__(self, message: str = ..., /, **options: Any) -> None: ...
    def __rich__(self) -> Text: ...
    def __trigger__(self) -> None: ...
    def __replace__(self, *unused: Never, **overrides: Any) -> CommandWarning: ...

class EmptyOptionValueWarning(CommandWarning): ...
class DeprecatedArgumentWarning(CommandWarning): ...
class DelegatedCommandWarning(CommandWarning): ...

class CommandExit(ExceptionGroup[CommandException]):
    exceptions: Sequence[CommandException]
    options: Mapping[str, Any]
    def __init__(self, exceptions: Iterable[CommandException], **options: Any) -> None: ...
    def __rich__(self) -> Text: ...
    def __trigger__(self) -> None: ...
    def __replace__(self, *unused: Never, **overrides: Any) -> CommandExit: ...


def trigger(fault: Triggerable, /, **options: Any) -> None: ...
def getdoc(code: FaultCode, /) -> str | None: ...
