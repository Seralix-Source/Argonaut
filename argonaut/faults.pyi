from collections.abc import Iterable, Sequence, Mapping
from typing import Protocol, Never, Any
from typing import type_check_only  # NOQA: Needed

from argonaut.internals import UnsetType


@type_check_only
class Triggerable(Protocol):
    def __trigger__(self) -> None: ...
    def __replace__(self, *unused: Never, **overrides: Any) -> Triggerable: ...

class CommandException(Exception):
    message: str | UnsetType
    options: Mapping[str, Any]
    def __init__(self, message: str = ..., /, **options: Any) -> None: ... ...
    def __replace__(self, *unused: Never, **overrides: Any) -> CommandException: ...

class MalformedTokenError(CommandException): ...
class UnknownModifierError(CommandException): ...
class FlagTakesNoParamError(CommandException): ...
class UnknownCommandError(CommandException): ...
class UnknownSubcommandError(CommandException): ...
class TooManyPositionalsError(CommandException): ...
class DuplicateModifierError(CommandException): ...
class InlineParamRequiredError(CommandException): ...
class MissingParamError(CommandException): ...
class AtLeastOneParamRequiredError(CommandException): ...
class NotEnoughParamsError(CommandException): ...
class TooManyInlineParamsError(CommandException): ...
class InvalidParamError(CommandException): ...
class DisallowedParamError(CommandException): ...
class UncastableParamError(CommandException): ...
class InvalidChoiceError(CommandException): ...
class ConflictingGroupError(CommandException): ...
class StandaloneOnlyError(CommandException): ...
class UnparsedInputError(CommandException): ...

class CommandWarning(Warning):
    message: str | UnsetType
    options: Mapping[str, Any]
    def __init__(self, message: str = ..., /, **options: Any) -> None: ... ...
    def __replace__(self, *unused: Never, **overrides: Any) -> CommandWarning: ...

class EmptyInlineParamWarning(CommandWarning): ...
class DeprecatedArgumentWarning(CommandWarning): ...
class ExternalConverterWarning(CommandWarning): ...

class CommandExit(ExceptionGroup[CommandException]):
    exceptions: Sequence[CommandException]
    options: Mapping[str, Any]
    def __init__(self, exceptions: Iterable[CommandException], **options: Any) -> None: ...
    def __trigger__(self) -> None: ...
    def __replace__(self, *unused: Never, **overrides: Any) -> CommandExit: ...

def trigger(fault: Triggerable, /, **options: Any) -> None: ...
